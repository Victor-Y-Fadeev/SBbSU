Семестр 1
=========
### Домашняя работа 11
[Лексический анализ (презентация)](https://docs.google.com/presentation/d/1Cnlox807bUDrApmSrzEN2bTfdLlYAiT1lJtOpcqUmjA/edit) <br/>
[Лексический анализ (конспект)](https://docs.google.com/document/d/17nLYPWR-H1-8LkT4nn2ZpkTiWoCGkguzNG4uGCG_zuw/edit#heading=h.sxn2ja29yp2o) <br/>
[Синтаксический анализ (презентация)](https://docs.google.com/presentation/d/1Qv2RPoKtsXG-41WMZz5ODrvJcBTZ8LvbpYWJvkf5dRI/edit#slide=id.p) <br/>
[Синтаксический анализ (конспект)](https://docs.google.com/document/d/1HS-VeSMz0FCTPB8e-kgKXuvqH1Y9j28mnwtJXRiVge4/edit)

- [11.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw11/task1) <br/>
Реализовать лексический анализатор, проверяющий, является ли введённая последовательность символов вещественным числом (вещественное число задаётся регулярным выражением (+ | -)? digit+ (. digit+)? (E(+ | -)? digit+)?, где digit -- [0..9]). Реализовывать можно как больше нравится: либо через switch, либо таблицей переходов.
- [11.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw11/task2) <br/>
Реализовать синтаксический анализатор, разбирающий арифметические выражения методом рекурсивного спуска. Входной поток составляют числа, разбираемые лексическим анализатором из прошлого задания, и знаки операций `+, -, /, *`.


### Домашняя работа 10
[Консоль и системы сборки](https://docs.google.com/presentation/d/1wORxD1VB8p1dlMhiO3X96_5xkwQZLO25FdX-qnb7XHI/edit?usp=sharing)

- [10.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw10/task1) <br/>
Реализовать кодирование текста с помощью [алгоритма Хаффмана](https://habrahabr.ru/post/144200/). На входе программы файл с текстом из латинских букв, пробелов и знаков препинания. На выходе текстовый файл, состоящих из двух строк. Первая строка содержит в себе представление дерева, которое строится в ходе работы алгоритма (например, в отладочном варианте из задачи [7.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1#%D0%94%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D1%8F%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-7)), вторая строка — последовательность нулей и единиц, в которую кодируется входной текст. Крайне приветствуется вывод таблицы частоты вхождения символов исходного текста.
- [10.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw10/task2) <br/>
Реализовать раскодирование с помощью алгоритма Хаффмана. На входе файл, генерируемый программой из задачи 1, на выходе — исходный закодированный текст.


### Домашняя работа 9
[Парадигмы программирования (конспект)](https://drive.google.com/open?id=1kb0heLa3-DZiye3e8AFC7UDXimicdnfbGC_tI7_Ea4A) <br/>
[Парадигмы программирования (презентация, часть 1)](https://drive.google.com/open?id=1TNDtM0QCTG9sKxJpVZNVR2oHGHfd3PFELvPqj5bPdQc) <br/>
[Парадигмы программирования (презентация, часть 2)](https://drive.google.com/open?id=1y7U7AM4qY11c_uo99THWsrLlXsh4ELeJwrgGsV1GwLM) <br/>
[Графы (презентация)](https://docs.google.com/presentation/d/1PpjKXycB6RqEtWaRWxb57wAvajDHW8Aup8GQumBcHt0/edit?usp=sharing) <br/>
[Графы (конспект)](https://docs.google.com/document/d/1e6GXRLHaYWunbzOXs4V_Zh1BWF-VUQoHOw1tAlxAkQg/edit?usp=sharing)

- [9.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw9/task1) <br/>
В некоторой стране n городов, соединенных между собой дорогами различной длины. По каждой дороге можно проехать в обе стороны. 1 сентября 1939 г. силы вермахта подло вторглись в эту страну и захватили город с номером 1. Далее, каждый день они захватывали по одному городу, используя следующий алгоритм: среди всех еще не захваченных городов выбирается ближайший к городу 1 и захватывается. Во входном файле заданы n — число городов и m — число дорог. Далее следуют сами дороги в формате: "i j len", i и j — номера городов, len — длина дороги. Задача: вывести номера городов в порядке захвата, а также и расстояние и путь от каждого захваченного города до города 1. Города нумеруются с 1.
- [9.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw9/task2) <br/>
Реализовать алгоритм A* для поиска пути на двумерной карте. Карта задаётся двумерным массивом в файле, где каждой пустой клетке соответствует 0, а каждой занятой 1. На входе программы координаты точек начала и конца пути. Программа должна нарисовать в консоли заданную карту и проложенный алгоритмом путь. (Вывод отладочной информации на этой карте также приветствуется.)
- [9.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw9/task3) <br/>
Реализовать алгоритм Рабина-Карпа поиска подстроки в строке (программа должна выводить индексы всех вхождений).


### Домашняя работа 8
[Хеш-таблицы](https://drive.google.com/open?id=1yTmL_376CgMh4NNoxJu-sgRczaeuUMuPwQRDhyoNx3I) <br/>
[git (презентация)](https://drive.google.com/open?id=1TwMIvyj5tnJoLJxJeI1TB6rpzrGbxbz7JvBTbn2B1nw) <br/>
[git (конспект)](https://drive.google.com/open?id=13NNbcrF13TPRUmRrpsaF27BLgYB53kBkYpbAHY1NMgw) <br/>
[Алгоритм Кнута-Морриса-Пратта](https://drive.google.com/open?id=0B00yIfwI356ASjAzeTJjSWVPT2RUS1E4RERiYkJ0NklzLXFN)

- [8.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw8/task1) <br/>
Получив домашнее задание по программированию, группа студентов приступила к решению задач. Три студента с номерами 1, 2 и 3 честно сделали все задание самостоятельно, другие решили списать с кого-нибудь, кто уже имеет готовое решение — либо решенное самостоятельно, либо уже списанное с другого. При проверке выяснилось, что некоторых студентов следует немедленно отчислить, т.к. они не только не написали решение сами, но и поленились списать. Задача: Определить, какой студент какое решение сдавал, и кого надо отчислить. На входе: количество студентов и список пар чисел, где первое число — номер студента, второе — номер того, с кого было списано решение. Требуется вывести список пар чисел, где первое число — номер студента, второе — 1, 2 или 3 — сданный вариант.
- [8.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw8/task2) <br/>
Описать модуль для работы с АТД "Строка" со следующими операциями: создание, удаление, копирование (функцию clone(), возвращающую полную копию строки), конкатенация (дописывание строки-аргумента к текущей), сравнение на равенство, вычисление длины, проверка на пустоту, выделение подстроки, преобразование к char*. Строка должна быть потенциально расширяемой в неограниченных пределах.
- [8.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw8/task3) <br/>
Реализовать алгоритмы для работы с хэш-таблицей (разрешение коллизий методом цепочек). По данному тексту (читается из файла, не ограничен по размеру) посчитать число использований каждого слова. Вывести load factor, среднюю длину цепочки, максимальную длину цепочки и значения, которые в нее попали, общее число добавленных слов, число пустых ячеек таблицы. Для работы со строками использовать модуль "Строка" из задачи 2.
- [8.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw8/task4) <br/>
Выложить весь свой предыдущий код (все зачтённые задачи) на github.


### Домашняя работа 7
[Деревья (презентация)](https://docs.google.com/presentation/d/1Xrdn0O-ZsVwvo53_KXQ-_-MFGIDdMKzjiixABF-jtfE/edit?usp=sharing) <br/>
[АВЛ дерево](https://docs.google.com/document/d/1hNYn9yU-RRZSp8HSfJn0D_Kjw7eKgOhrSePhqgM_NPo/edit#) <br/>
[Деревья (конспект)](https://docs.google.com/document/d/10G7ZSF94RFb-_8cnYhnZ-y-wDYGlYPjv08Gi4BTg034/edit#heading=h.hgh7ig7bjq3r)

- [7.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw7/task1) <br/>
Реализовать АТД "множество" на основе двоичного дерева поиска. Программа должна позволять в интерактивном режиме добавлять значения целого типа в множество, удалять значения, проверять, принадлежит ли значение множеству, печатать текущие элементы множества в возрастающем и убывающем порядках, а также в формате (a b c), где a — значение в узле, а b и c — аналогичные представления поддеревьев правого и левого потомка. Пример: "(5 (2 null null) (10 null (12 null null)))". Такой вывод бывает крайне полезен при отладке операций над деревом.
- [7.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw7/task2) <br/>
По дереву разбора арифметического выражения вычислить его значение. Дерево разбора хранится в файле в виде (<операция> <операнд1> <операнд2>), где <операнд1> и <операнд2> сами могут быть деревьями, либо числами. Например, выражение (1 + 1) * 2 представляется в виде (* (+ 1 1) 2). Должны поддерживаться операции `+, -, *, /` и целые числа в качестве аргументов. Требуется построить дерево в явном виде, распечатать его (не обязательно так же, как в файле), и посчитать значение выражения обходом дерева. Может быть полезна функция ungetc. Можно считать, что входной файл корректен. Пример: по входному файлу ( (+ 1 1) 2) может печататься ((1 + 1) * 2) и выводиться 4.
- [7.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw7/task3) <br/>
Переделать множество из задачи 1 на основе АВЛ-дерева.


### Домашняя работа 6
[Представление данных (презентация)](https://docs.google.com/presentation/d/1vYScuK9ufiN5l46zSAfbP9Y33kOHs-p0RyRC7uiQjUI/edit#slide=id.g173453b90b_0_82) <br/>
[Представление данных (конспект)](https://docs.google.com/document/d/1LibDaZ7YWjoqIPXKLGAiS30l-DlGR_8iwnrtS1yiAqY/edit#heading=h.axakwg86vdi)

- [6.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw6/task1) <br/>
По содержимому памяти вывести значение типа double в экспоненциальной форме: sm * q<sup>Sp</sup>, где s — знак мантиссы, m — мантисса, q — основание системы счисления, S — знак порядка, p — порядок числа. Примеры допустимого вывода: <br/>
Enter a number: -2.5 <br/>
Result: -1.25 * 2<sup>1</sup> <br/>
Enter a number: 12312.323 <br/>
Result: +1.5029691162109375384 * 2<sup>13</sup>
- [6.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw6/task2) <br/>
Ввести два числа, перевести в двоичное представление (в каком-либо из кодов) и в этом двоичном виде напечатать, сложить, вывести сумму в двоичном и десятичном виде.
- [6.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw6/task3) <br/>
Дан массив с коэффициентами многочлена от x. Требуется написать программу, "красиво" выводящую этот многочлен на консоль. Например, многочлен, представляемый коэффициентами -1 12321 0 0 0 -1 -1 -1 1 1 34 -2 0 0, выводится так: <br/>
![картинка](http://i.imgur.com/LkLHotA.png)
- [6.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw6/task4) <br/>
Написать программу, которая считает количество непустых строк в исходном файле. Строка считается пустой, если состоит только из пробелов и табуляций (символ \t), или в ней нет символов вообще.


### Домашняя работа 5

- [5.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw5/task1) <br/>
Написать программу, которая в диалоговом режиме позволяет осуществлять следующие операции: <br/>
0 - exit; <br/>
1 - add a value to sorted list; <br/>
2 - remove a value from sorted list; <br/>
3 - print list. <br/>
Все операции должны сохранять сортированность. Начинаем с пустого списка. Список должен быть оформлен отдельным модулем.
- [5.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw5/task2) <br/>
"Считалочка" — отряд из 41-го сикария, защищавший галилейскую крепость Массада, не пожелал сдаваться в плен блокировавшим его превосходящим силам римлян. Сикарии стали в круг и договорились, что каждые два воина будут убивать третьего, пока не погибнут все. Самоубийство — тяжкий грех, но тот, кто в конце концов останется последним, должен будет его совершить. Иосиф Флавий, командовавший этим отрядом, якобы быстро рассчитал, где нужно стать ему и его другу, чтобы остаться последними, но не для того, чтобы убить друг друга, а чтобы сдать крепость римлянам. В нашем случае участвует n воинов и убивают каждого m-го. Требуется определить номер k начальной позиции воина, который должен будет остаться последним. Считать с помощью циклического списка, который должен быть оформлен отдельным модулем.
- [5.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw5/task3) <br/>
Вывести на консоль все однострочные комментарии С++ (вида // комментарий) из входного файла (вместе с символами "//"). До комментария в строке может быть значимый текст, его выводить не надо, строки без комментариев не выводить. Конец строки представляется символом '\n', могут быть полезны функции fgetc и feof. Программа должна учитывать случаи, когда последовательность "//" находится внутри текстовой строки или многострочного комментария (/* */). В таких случаях ничего выводить не нужно.
- [5.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw5/task4) <br/>
Написать программу-телефонный справочник. Она должна уметь хранить имена и номера телефонов, в интерактивном режиме осуществлять следующие операции: <br/>
0 - выйти <br/>
1 - добавить запись (имя и телефон) <br/>
2 - найти телефон по имени <br/>
3 - найти имя по телефону <br/>
4 - сохранить текущие данные в файл. <br/>
При запуске программа должна читать данные из файла, если файла нет — начинать с пустой базы номеров. Формат представления данных в файле придумать самостоятельно.


### Домашняя работа 4
[Структуры, стек](https://docs.google.com/document/d/1cfDiJ33hMBSNRBqSTFy1JnPNR9DfIpLaoIJ92eJXLeI/edit?usp=sharing) <br/>
[Списки, очередь](https://drive.google.com/open?id=1bJzpyDmnkUBOrfr5pba8k8-vMdN-Gvh5Kneq7TOnfxw) <br/>
[О разработке ПО (презентация)](https://docs.google.com/presentation/d/1RE-_bGaBgV6wGNpZS98dqO954EGsKoZXWZSTFx351oo/edit#slide=id.p) <br/>
[О разработке ПО (конспект)](https://docs.google.com/document/d/1leEESZUfuSeiGkkB_aJeERCtp5q-V84WTbag7QPvIyw/edit)

- [4.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw4/task1) <br/>
Дан массив размерностью n x n, n — нечетное число. Вывести элементы массива при обходе его по спирали, начиная с центра.
- [4.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw4/task2) <br/>
Дан файл с текстом. Вывести все слова этого текста, предварительно оставив в каждом слове только первые вхождения каждой буквы.
- [4.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw4/task3) <br/>
Написать программу преобразования инфиксной формы выражения в постфиксную. Известно, что каждый операнд занимает один символ. В выражении могут быть знаки `+, -, *, /`, скобки и цифры. Пример: (1 + 1) * 2 должно преобразовываться в 1 1 + 2 *. Алгоритм перевода предлагается найти самостоятельно (алгоритм "сортировочной станции" Э. Дейкстры).
- [4.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw4/task4) <br/>
Реализовать программу, вычисляющую значение выражения в постфиксной записи с помощью стека.
- [4.5](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw4/task5) <br/>
Объединить предыдущие две задачи в одну программу — реализовать программу-калькулятор, вычисляющую значение арифметического выражения в инфиксной нотации. Выражение вводится с консоли, должны поддерживаться операции `+, -, *, /` и скобки, операнды считать односимвольными.


### Домашняя работа 3
[Сложность](https://docs.google.com/document/d/10jKM5i0vaDHJZ0Rn7CaE9rBO1G1poPMUc8oxayq4E-Y/edit) <br/>
[Память и указатели](https://docs.google.com/document/d/1Kz5U8PgO2Y4wI-GDjGREDLJeEvJmNgmqijK5vWuSD9k/edit#heading=h.3s8l4acj950s)

- [3.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw3/task1) <br/>
Реализовать возведение в целую степень с логарифмической сложностью алгоритма.
- [3.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw3/task2) <br/>
Найдите максимальный элемент массива, встречающийся более одного раза (массив неупорядоченный).
- [3.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw3/task3) <br/>
Даны две строки. Определить, можно ли, переставляя символы в первой строке, получить вторую строку. Хочется решение быстрее, чем за O(n<sup>2</sup>).
- [3.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw3/task4) <br/>
Написать программу, которая переставляет цифры натурального числа таким образом, чтобы образовалось наименьшее число, записанное этими же цифрами.
- [3.5](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw3/task5) <br/>
С клавиатуры вводятся 2 числа n и k (1 <= n <= 5000, 1 <= k <= 300000), сгенерировать массив из n чисел от 0 до 10<sup>9</sup>, сгенерировать k целых чисел от 0 до 10<sup>9</sup> , для каждого из них проверить, содержится ли оно в массиве. Придумать алгоритм с временной сложностью O(n log n + k log n), или лучший.


### Домашняя работа 2
[Сортировки](https://docs.google.com/document/d/1q67xg0fj14F_2btxkXGl1hXoJo5JIn4Pwc70gRyPPWM/edit?usp=drive_web)

- [2.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw2/task1) <br/>
Реализовать рекурсивный и итеративный подсчет чисел Фибоначчи.
- [2.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw2/task2) <br/>
Реализовать быструю сортировку (в рекурсивном варианте).
- [2.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw2/task3) <br/>
Напечатать все представления натурального числа N суммой натуральных слагаемых. Перестановка слагаемых нового способа не дает.
- [2.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw2/task4) <br/>
Напечатать в порядке возрастания все простые несократимые дроби, заключенные между 0 и 1, знаменатели которых не превышают n.
- [2.5](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw2/task5) <br/>
Реализовать алгоритм пирамидальной сортировки.
- [2.6](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw2/task6) <br/>
Реализовать консольную игру ["Быки и коровы"](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D0%BA%D0%B8_%D0%B8_%D0%BA%D0%BE%D1%80%D0%BE%D0%B2%D1%8B).


### Домашняя работа 1
[Квалификационные требования по профессии "Программист"](http://se.math.spbu.ru/SE/SE/programer.doc) <br/>
[Соглашение об оформлении кода](http://se.math.spbu.ru/SE/Members/ylitvinov/styleguide) <br/>
[Хорошая статья про красивый код](https://habrahabr.ru/post/266969/)

- [1.1](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task1) <br/>
Написать программу, считающую значение формулы x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x + 1 за два умножения.
- [1.2](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task2) <br/>
Реализовать алгоритм нахождения неполного частного от деления a на b (целые числа), используя только операции сложения, вычитания и умножения.
- [1.3](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task3) <br/>
Дан массив целых чисел x[1]...x[m+n], рассматриваемый как соединение двух его отрезков: начала x[1]...x[m] длины m и конца x[m+1]...x[m+n] длины n. Не используя дополнительных массивов, переставить начало и конец.
- [1.4](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task4) <br/>
Посчитать число "счастливых билетов" (билет считается "счастливым", если сумма первых трёх цифр его номера равна сумме трёх последних).
- [1.5](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task5) <br/>
Написать программу проверки баланса скобок в исходной строке (т.е. число открывающих скобок равно числу закрывающих и выполняется правило вложенности скобок).
- [1.6](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task6) <br/>
Заданы две строки: needle и haystack. Найти количество вхождений needle в haystack как подстроки.
- [1.7](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task7) <br/>
Написать программу, печатающую все простые числа, не превосходящие заданного числа.
- [1.8](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task8) <br/>
Реализовать подсчет факториала (рекурсивно и итеративно).
- [1.9](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task9) <br/>
Посчитать целую степень числа: a<sup>n</sup>.
- [1.10](https://github.com/Victor-Y-Fadeev/SPbSU/tree/master/course1/sem1/hw1/task10) <br/>
Реализовать программу, проверяющую, является ли строка палинромом.
